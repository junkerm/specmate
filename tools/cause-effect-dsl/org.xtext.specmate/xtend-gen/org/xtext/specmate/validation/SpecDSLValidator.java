/**
 * generated by Xtext 2.17.1
 */
package org.xtext.specmate.validation;

import java.util.List;
import java.util.Stack;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.xtext.specmate.resolve.matcher.Matcher;
import org.xtext.specmate.resolve.matcher.MatcherException;
import org.xtext.specmate.resolve.matcher.SubtreeMatcher;
import org.xtext.specmate.resolve.util.RuleUtility;
import org.xtext.specmate.specDSL.Rule;
import org.xtext.specmate.specDSL.SpecDSLPackage;
import org.xtext.specmate.validation.AbstractSpecDSLValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class SpecDSLValidator extends AbstractSpecDSLValidator {
  @Check
  public void checkRule(final Rule rule) {
    try {
      Matcher match = RuleUtility.transform(rule);
      Stack<Matcher> workStack = new Stack<Matcher>();
      workStack.add(match);
      while ((!workStack.isEmpty())) {
        {
          Matcher currentMatch = workStack.pop();
          boolean _hasChildren = currentMatch.hasChildren();
          if (_hasChildren) {
            if (((!(currentMatch instanceof SubtreeMatcher)) && (currentMatch.getParent() != null))) {
            }
            List<Matcher> _childMatchers = currentMatch.getChildMatchers();
            for (final Matcher m : _childMatchers) {
              workStack.push(m);
            }
          }
        }
      }
    } catch (final Throwable _t) {
      if (_t instanceof MatcherException) {
        final MatcherException e = (MatcherException)_t;
        this.error(e.getMessage(), SpecDSLPackage.Literals.RULE__DEPENDENCIES);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
}
